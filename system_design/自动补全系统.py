"""
算法：
字典树记录每个单词（前缀）出现的频率。
p: 用户输入前缀的长度
n: 字典树节点的个数
c: 给定节点的子节点数

根据输入前缀，获取排名前k最常被搜索的单词的时间复杂度：
O(p) + O(c) + O(clogc)

优化：
1. 限制前缀的长度，即减小O(p)
2. 在每个节点缓存最常被搜索到的k个单词

字典树数据库：
1. 文档存储：将字典树序列化，并以文档存入数据库（MongoDB）
2. 键值存储：每个前缀都可以映射成key


数据收集服务：
用户的每次输入不一定都要更新入字典树，否则会严重降低查询速度。
一旦字典树被创建，高频词的建议不会经常变化。
用户的输入会记录入数据库（查询词、时间），可以每隔一段时间聚合数据（查询词、时间、频率），并更新字典树。
根据场景，更新频率不同，如推特可能需要短时间更新，而谷歌不需要。
使用一组worker定期根据数据库构建新的字典树；
使用字典树缓存实现快速读，定期从数据库拉取最新数据；


查询服务：
查询请求 -> 负载均衡器 -> API服务器 -> 字典树缓存 -> 字典树数据库
若请求不在缓存中，则将数据填充至缓存。

优化查询：
1. ajax异步处理，不需要加载整个页面。
2. 使用浏览器缓存（谷歌浏览器会缓存1小时你的搜索补全结果）。


字典树操作：
1. 创建：根据聚合数据创建，来源是数据库
2. 更新：a. 每周重新构建 b. 直接更新字典树，操作较慢，字典树较小时使用
3. 删除：在字典树缓存和api服务器间增加过滤层，过滤不良的补全建议，并从字典树中删除

扩展存储
可以根据英文首字母将26棵字典树保存在26个服务器上，当需要大规模的数据时，（其他语言可以使用unicode）
可以继续分片，如aa, ab, ac ...
这样可能导致分配不均，因为不同字母开头的数据量可能差距很大，所以要根据历史数据进行智能的分片，
如s开头单独一个分片，而u,x,y,z可以共享一个分片。
"""
